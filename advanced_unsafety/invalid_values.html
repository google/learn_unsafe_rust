<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Invalid values - Learn unsafe Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn unsafe Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="invalid-values"><a class="header" href="#invalid-values">Invalid values</a></h1>
<blockquote>
<p><em>“If you tell the truth, you don't have to remember anything.”</em>_
— <em>Mark Twain</em></p>
</blockquote>
<p>Values of a particular type in Rust may never have an "invalid" bit pattern for that type. This is true even if that value is never read from afterwards, or if that value simply exists behind an unread reference. From <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">the reference</a>:</p>
<blockquote>
<p>"Producing" a value happens any time a value is assigned to or read from a place, passed to a function/primitive operation or returned from a function/primitive operation.</p>
</blockquote>
<p>A lot of basic types <em>don't</em> have any rules about invalid values. For example, all bit patterns of the integer types (and arrays of the integer types) are valid. But most other types have some concept of validity.</p>
<h2 id="types-of-invalid-values"><a class="header" href="#types-of-invalid-values">Types of invalid values</a></h2>
<h3 id="uninitialized-memory"><a class="header" href="#uninitialized-memory">Uninitialized memory</a></h3>
<p>Values of <em>any</em> type can be "uninitialized", which is considered instantly UB even for types like integers. We discuss this further in <a href="../advanced_unsafe/uninitialized.html">the chapter on uninitialized memory</a>. For now this chapter will largely cover cases where a type may have an invalid <em>bit pattern</em>, rather than other cases where it may be invalid due to e.g. not having an initialized bit representation at all.</p>
<h3 id="primitive-types-with-invalid-values"><a class="header" href="#primitive-types-with-invalid-values">Primitive types with invalid values</a></h3>
<p><code>bool</code>s that have bit patterns other than those for <code>true</code> and <code>false</code> are invalid. The same goes for <code>char</code>s representing byte patterns that are considered invalid in UTF-32 (anything that is either a surrogate character, or greater than <code>char::MAX</code>).</p>
<h3 id="pointers-with-invalid-values"><a class="header" href="#pointers-with-invalid-values">Pointers with invalid values</a></h3>
<p><code>&amp;T</code> and <code>&amp;mut T</code> may not be null, nor may they be <a href="../core_unsafety/dangling_and_unaligned_pointers.html">unaligned</a> for values of type <code>T</code>.</p>
<p><code>fn</code> pointers and the metadata part of <code>dyn Trait</code> may not be null either.</p>
<p>Most smart pointer types like <code>Box&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> are invalid when null. Library types may achieve the same behavior using the <a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a> pointer type.</p>
<p>It's also currently invalid for <code>Vec&lt;T&gt;</code> to have a null pointer for its buffer! <code>Vec&lt;T&gt;</code> uses <a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a> internally, and empty vectors use a pointer value equal to the alignment of <code>T</code>.</p>
<p>While the details have not been hammered out yet (<a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/412">UCG #412</a> and related issues), generally a reference type (<code>&amp;T</code>) should be considered valid if the underlying pointer is dereferenceable (points to valid memory).</p>
<p>A special case of this is zero-sized types, which are allowed to point to "dangling" memory as long as it is not memory that has been <em>deallocated</em>. Furthermore, pointers to zero sized types constructed from integer <em>literals</em> are always valid, <a href="https://doc.rust-lang.org/std/ptr/index.html#safety">see the <code>std::ptr</code> docs</a>.</p>
<p><code>Vec&lt;T&gt;</code> is a bit of a special case where is allowed to refer to invalid-but-aligned-and-non-null memory when it is empty.</p>
<p>There are a lot of other reasons that a pointer type may not be valid, but these are the ones having to do with the bit pattern and memory allocation. We'll be covering the others in more depth in other chapters (@@note: where?).</p>
<h4 id="shallow-vs-deep-validity"><a class="header" href="#shallow-vs-deep-validity">"shallow" vs "deep" validity</a></h4>
<p>An open question in Rust's model is whether references and reference-like types have "shallow" validity (roughly, the rules above), or "deep" validity (where a reference is valid only when the pointed-to data is valid, and that applies transitively). This issue is tracked upstream as <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/77">UGC #77</a>. The current discussion seems to skew towards shallow validity as opposed to deep validity, but this may change.</p>
<p>For the purposes of <em>writing</em> unsafe code, it is convenient to imagine the boundary as being such that <code>&amp;T</code>/<code>&amp;mut T</code> references should never point to memory containing invalid values of type <code>T</code>. However, when auditing existing unsafe code it may be okay to allow scenarios that assume only shallow validity is required, depending on your risk appetite.</p>
<h3 id="enums-with-invalid-values"><a class="header" href="#enums-with-invalid-values">Enums with invalid values</a></h3>
<p>Any bit pattern not covered by a variant of an enum is also invalid. For example, with the following enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Colors {
    Red = 1,
    Orange = 2,
    Yellow = 3,
    Green = 4,
    Blue = 5,
    Indigo = 6,
    Violet = 7,
}
<span class="boring">}</span></code></pre></pre>
<p>a bit pattern of <code>8</code> or <code>0</code> (assuming that it gets represented as the explicit discriminant integers) is undefined behavior.</p>
<p>Or in this enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Stuff {
    Char(char),
    Number(u32),
}
<span class="boring">}</span></code></pre></pre>
<p>setting the discriminant bit to something that is not the discriminant of <code>Char</code> or <code>Number</code> is invalid. Similarly, setting the discriminant bit to that for <code>Char</code> but having the value be invalid for a <code>char</code> is also invalid.</p>
<h3 id="str"><a class="header" href="#str"><code>str</code></a></h3>
<p>The string slice type <code>str</code> does not actually have any validity constraints: Despite being only for UTF-8 encoded strings, it is valid for <code>str</code>s to be in any bit pattern, provided you do not call any methods on the string that are not about directly accessing the memory behind it.</p>
<p>Basically, the UTF-8 validity of <code>str</code> is an implicit safety requirement for most of its methods, however it is fine to <em>hold on to</em> an <code>&amp;str</code> that points to random bytes. This is a difference between things being "insta-UB" and "UB on use": invalid value UB is typically "insta UB" (it's UB even if you don't <em>do</em> anything with the invalid value), but here you're allowed to do this as long as you don't use the data in certain ways.</p>
<p>This is something that can be relied on when doing things like manipulating or constructing <code>str</code>s byte-by-byte, where there may be intermediate invalid states.</p>
<p>Of course, reference types like <code>&amp;str</code> must still satisfy all of the rules about reference validity (being non-null, etc).</p>
<h3 id="invalid-values-for-general-library-types"><a class="header" href="#invalid-values-for-general-library-types">Invalid values for general library types</a></h3>
<p>In general, types may have various invalid values based on their internal representation (which may not be stable!).
In addition to <a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a>, the Rust standard library provides <a href="https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html"><code>NonZeroUsize</code></a> and a bunch of other similar <code>NonZero</code> integer types that work as its integer counterparts, and libraries may use these internally.</p>
<p>Note that Rust's default representation for types is not stable! What might be a valid bit pattern one day may become invalid later, unless you're only relying on things that are known to be invariant. Converting a type to its bits, sending it over the network, and converting it back is extremely fragile, and will break if the two sides are on different platforms or even Rust versions.</p>
<p>As a library user you may not assume anything about the representation of a library type unless it is explicitly documented as such, or if it has a public representation that is known to be stable (for example a public <code>#[repr(C)]</code> enum)</p>
<h2 id="when-you-might-end-up-making-an-invalid-value"><a class="header" href="#when-you-might-end-up-making-an-invalid-value">When you might end up making an invalid value</a></h2>
<p>Invalid values have a chance to crop up when you're reinterpreting a chunk of memory as a value of a different type. This can happen when calling <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>mem::transmute()</code></a>, <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html"><code>mem::transmute_copy()</code></a>, or <a href="https://doc.rust-lang.org/stable/std/mem/fn.zeroed.html"><code>mem::zeroed()</code></a>, when casting a reference to a region of memory into one of a different type, or when accessing the wrong variant of a <code>union</code>. The value need not be on the stack to be considered invalid: if you gin up an <code>&amp;bool</code> that points to a bit pattern that is not a valid <code>bool</code>, that can instantly be UB (in a "deep validity" world) even if you don't read from the reference.</p>
<p>Note that since <a href="../advanced_unsafe/uninitialized.html">uninitialized memory</a> is a type of invalid value, any way to produce uninitialized memory (including <a href="https://doc.rust-lang.org/stable/std/mem/fn.uninitialized.html"><code>mem::uninitialized()</code></a>) is also a way of producing invalid values.</p>
<p>Invalid values can also be created when receiving values over FFI where either the signature of the function is incorrect (e.g. saying an FFI function accepts <code>bool</code> when the other side thinks it accepts a <code>u8</code>), or where there are differences in notions of validity across languages.</p>
<p>A subtle case of this comes up occasionally in FFI code due to differences in expectations between how enums are used in Rust and C.</p>
<p>In C, it is common to use enums to represent <em>bitmasks</em>, doing something like this:</p>
<pre><code class="language-c">typedef enum {
    Active = 0x01;
    Visible = 0x02;
    Updating = 0x03;
    Focused = 0x04;
} NodeStatus;
</code></pre>
<p>where the value make take states like <code>Active | Focused | Visible</code>. These combined values, as well as the "no flags set" value <code>0</code> are invalid in Rust. If this type is represented as an enum in Rust (<a href="https://doc.rust-lang.org/reference/type-layout.html#reprc-field-less-enums">even if it is <code>#[repr(C)]</code></a>!), it will be UB to accept values of this type over FFI from C. Generally in such cases it is recommended to use an integer type instead, and represent the mask values as constants.</p>
<h2 id="signs-an-invalid-value-was-involved"><a class="header" href="#signs-an-invalid-value-was-involved">Signs an invalid value was involved</a></h2>
<p>The compiler is allowed to assume that values are never invalid; and it may use invalid states to signal other things, or pack types into smaller spaces.</p>
<p>For example, the type <code>Option&lt;Box&lt;T&gt;&gt;</code> will use the fact that the reference cannot be null to fit the entire type into the the same space <code>Box&lt;T&gt;</code> takes up, with the null pointer state representing <code>None</code>.</p>
<p>This can go even further with stuff like <code>Option&lt;Option&lt;Option&lt;bool&gt;&gt;&gt;</code> fitting into a single byte, up to and including the type with 254 <code>Option</code>s surrounding one <code>bool</code>. This general class of optimization is known as a "niche optimization", with bits representing invalid values being called "niches".</p>
<p>In such scenarios, invalid values may lead to values being interpreted as a different value, for example an <code>Option&lt;NodeStatus&gt;</code> using the enum from above would be interpreted as <code>None</code> if <code>NodeStatus</code> were represented as a Rust enum and an "empty status" value was received over C.</p>
<p>Furthermore, invalid values will break <code>match</code> statements, usually (but not necessarily) leading to an abort.</p>
<p>Debuggers also tend to behave strangely with invalid values, displaying incorrect values, or even having the value change from read to read.</p>
<p>This is not an exhaustive list: ultimately, having an invalid value is UB and it remains illegal even if there are no optimizations that will break.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../advanced_unsafety/uninitialized.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../advanced_unsafety/pointer_aliasing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../advanced_unsafety/uninitialized.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../advanced_unsafety/pointer_aliasing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
