<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn unsafe Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="undefined_behavior.html"><strong aria-hidden="true">2.</strong> Undefined behavior</a></li><li class="chapter-item expanded "><a href="core_unsafety.html"><strong aria-hidden="true">3.</strong> Core unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_unsafety/dangling_and_unaligned_pointers.html"><strong aria-hidden="true">3.1.</strong> Dangling and unaligned pointers</a></li><li class="chapter-item expanded "><a href="core_unsafety/invalid_values.html"><strong aria-hidden="true">3.2.</strong> Invalid values</a></li><li class="chapter-item expanded "><a href="core_unsafety/data_races.html"><strong aria-hidden="true">3.3.</strong> Data races</a></li><li class="chapter-item expanded "><a href="core_unsafety/intrinsics.html"><strong aria-hidden="true">3.4.</strong> Intrinsics</a></li><li class="chapter-item expanded "><a href="core_unsafety/abi_and_ffi.html"><strong aria-hidden="true">3.5.</strong> ABI and FFI</a></li><li class="chapter-item expanded "><a href="core_unsafety/platform_features.html"><strong aria-hidden="true">3.6.</strong> Platform features</a></li><li class="chapter-item expanded "><a href="core_unsafety/inline_assembly.html"><strong aria-hidden="true">3.7.</strong> Inline assembly</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_unsafety.html"><strong aria-hidden="true">4.</strong> Advanced unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_unsafety/uninitialized.html"><strong aria-hidden="true">4.1.</strong> Uninitialized memory</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/pointer_aliasing.html"><strong aria-hidden="true">4.2.</strong> Pointer aliasing</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/immutable_data.html"><strong aria-hidden="true">4.3.</strong> Immutable data</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/atomic_ordering.html"><strong aria-hidden="true">4.4.</strong> Atomic ordering</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/pinning.html"><strong aria-hidden="true">4.5.</strong> Pinning</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/variance.html"><strong aria-hidden="true">4.6.</strong> Variance</a></li></ol></li><li class="chapter-item expanded "><a href="expert_unsafety.html"><strong aria-hidden="true">5.</strong> Expert unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="expert_unsafety/stacked_borrows.html"><strong aria-hidden="true">5.1.</strong> Stacked borrows</a></li><li class="chapter-item expanded "><a href="expert_unsafety/pointer_provenance.html"><strong aria-hidden="true">5.2.</strong> Pointer provenance</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn unsafe Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to &quot;Learn unsafe Rust&quot;, a compassionate and comprehensive resource for
learning unsafe Rust.</p>
<p>The materials in this book are broken down into three major volumes:</p>
<ol>
<li><a href="./core_unsafety.html">Core unsafety</a></li>
<li><a href="./advanced_unsafety.html">Advanced unsafety</a></li>
<li><a href="./expert_unsafety.html">Expert unsafety</a></li>
</ol>
<p>Each volume has multiple chapters. Those chapters can generally be read in any
order, whereas each chapter builds on the foundations laid by the previous
chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="undefined-behavior"><a class="header" href="#undefined-behavior">Undefined behavior</a></h1>
<blockquote>
<p><em>“People shouldn't call for demons unless they really mean what they say.”</em></p>
<p>— <em>C.S. Lewis, The Last Battle</em></p>
</blockquote>
<p>&quot;Undefined behavior&quot; is a bit of a strange notion. On one hand, the reference
<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">clearly defines</a> some (but not all) causes of undefined behavior.
This list includes some causes that are generally well-known: dereferencing a
null pointer, causing a data race, executing incorrect inline assembly. These
all have a direct translation for real, common machines and so it is common to
misunderstand &quot;undefined behavior&quot; to be &quot;platform-specific behavior&quot;. Maybe on
x86 it will continue on, perhaps on ARM it will cause a fault. While this can be
true, undefined behavior is usually more nuanced because of:</p>
<h2 id="abstract-machines"><a class="header" href="#abstract-machines">Abstract machines</a></h2>
<p>High-level programming languages allow programming for a wide variety of targets
by abstracting away the specific properties of each one, and targeting a single
&quot;abstract machine&quot;. C and C++ have their own &quot;abstract machines&quot;, and so does
Rust. This means that the semantics and rules of an abstract machine depend
heavily on the language that it's for.</p>
<p>When we write Rust code, we're writing code for this abstract machine. We're not
writing code that follows the rules for some set of targets; there is only one
set of rules for the abstract machine. It's just that the <em>consequences</em> for
breaking those rules depends on the target and the compiler itself. With this
perspective, it's easier to see that undefined behavior is platform-independent.</p>
<h2 id="rusts-abstract-machine"><a class="header" href="#rusts-abstract-machine">Rust's abstract machine</a></h2>
<p>Rust's abstract machine has not been rigorously defined, and it may never be.
Efforts to rigorously define Rust's abstract machine are usually colloquially
called &quot;standardizing Rust&quot;. You may even have heard of some of these efforts,
like the <a href="https://ferrous-systems.com/blog/the-ferrocene-language-specification-is-here/">Ferrocene Language Specification</a>. It's important to note
that these standards are for <em>some language arbitrarily close to Rust</em>; they're
not standards for the official Rust language.</p>
<p>Rather than describing the entirety of Rust's abstract machine, Rust's official
reference has defined just some of the rules of the abstract machine. Breaking
one of these rules definitely results in undefined behavior. These are the rules
that we'll cover in the <a href="./core_unsafety.html">Core unsafety</a> and
<a href="./advanced_unsafety.html">Advanced unsafety</a> volumes. There are also ideas about
undefined behavior that are being explored right now, but they haven't been
officially adopted as rules yet. Some of these are covered in the
<a href="./expert_unsafety.html">Expert unsafety</a> volume.</p>
<h2 id="triggering-undefined-behavior"><a class="header" href="#triggering-undefined-behavior">Triggering undefined behavior</a></h2>
<p>Undefined behavior in Rust is always triggered by some condition being met, and
usually this condition is just &quot;some code getting executed in a particular way&quot;
or &quot;some code violating an invariant upheld by the compiler&quot;. Because of this,
it's often tempting to think of undefined behavior as telling your program &quot;if
you get here, do whatever you want&quot;. However, undefined behavior is a purely
compile-time concept. It's not telling your program &quot;do whatever you want&quot;, it's
telling the compiler &quot;assume this can never happen&quot;. The compiler may not have a
better response than saying &quot;if you get here, panic&quot;. Or, it may be able to use
that promise to better optimize your code.</p>
<p>As an example, consider this Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hint::unreachable_unchecked;

unsafe fn char_to_int(c: char) -&gt; u8 {
    match c {
        '0' =&gt; 0,
        '1' =&gt; 1,
        '2' =&gt; 2,
        '3' =&gt; 3,
        '4' =&gt; 4,
        '5' =&gt; 5,
        '6' =&gt; 6,
        '7' =&gt; 7,
        '8' =&gt; 8,
        '9' =&gt; 9,
        _ =&gt; unsafe { unreachable_unchecked() },
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This converts a char <code>'0'..'9'</code> to its corresponding integer value. In the last
arm of the match, we call <code>unreachable_unchecked()</code>, which is a compiler hint
that says &quot;it would be undefined behavior to reach here&quot;. Because we promised
the compiler that <code>c</code> won't be any value other than <code>0..9</code>, it could optimize
this function into something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn char_to_int(c: char) -&gt; u8 {
    c as u8 - b'0'
}
<span class="boring">}</span></code></pre></pre>
<p>Consider what would happen if we called <code>char_to_int('A')</code>. <code>'A'</code> has a value of
<code>65</code> as a <code>u8</code>, and <code>'0'</code> has a value of <code>48</code> as a <code>u8</code>. So the optimized
version of our function would return <code>17</code>. But what if the compiler chose to
optimize our function a different way instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn char_to_int(c: char) -&gt; u8 {
    c as u8 &amp; 0b1111
}
<span class="boring">}</span></code></pre></pre>
<p>This does the same thing as our original version for all characters <code>'0'..'9'</code>.
Now consider what <em>this version</em> of our function would do if we called
<code>char_to_int('A')</code>. <code>'A'</code> has a value of <code>65</code> (<code>0b0010_0001</code> in binary
notation), so this version would return <code>0010_0111 &amp; 0000_1111 = 0111 = 15</code>.
This is a different result than we would have gotten with the previous
optimization!</p>
<p>Finally, consider this version:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn char_to_int(c: char) -&gt; u8 {
    let c = c as u8;
    if c &lt; b'0' || c &gt; b'9' {
        panic!()
    } else {
        c - b'0'
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This version doesn't return anything, it panics! In fact, the compiler would be
allowed to put <em>anything</em> in where the <code>panic!()</code> is located; the resulting
function would be just as correct and optimal as this one.</p>
<p>This strikes at the core of what &quot;undefined behavior&quot; is. The Rust compiler
transforms code based on a set of assumptions that always hold. If you break one
of these assumptions, then the behavior of your program is undefined because
it's impossible to know what transforms the compiler is doing based on them.</p>
<h2 id="unsoundness"><a class="header" href="#unsoundness">Unsoundness</a></h2>
<p>Now that we know exactly what undefined behavior is, we can understand what it
means for some Rust code to be <em>unsound</em>. Unsound code refers to either:</p>
<ul>
<li>An abstraction (e.g. a function or a trait) that can trigger undefined
behavior even when used as prescribed.</li>
<li>A particular invocation of unsafe code that causes undefined behavior under
allowed circumstances.</li>
</ul>
<p>This leads to two broad rules:</p>
<h3 id="if-you-can-trigger-undefined-behavior-with-purely-safe-code-its-unsound"><a class="header" href="#if-you-can-trigger-undefined-behavior-with-purely-safe-code-its-unsound">If you can trigger undefined behavior with purely safe code, it's unsound</a></h3>
<p>In purely safe code (that is, code that contains no <code>unsafe</code> blocks), the
compiler is in charge of enforcing all of the rules to avoid undefined behavior.
If we somehow manage to cause undefined behavior, then there must be some API
that we use which is unsound.</p>
<p>This is also why it can be difficult to build safe abstractions around unsafe
code. It's your job as the abstraction designer to make sure that no possible
arrangement of safe code can cause undefined behavior. That's a lot to consider!</p>
<h3 id="unsafe-code-must-accurately-document-its-safety-conditions-or-its-unsound"><a class="header" href="#unsafe-code-must-accurately-document-its-safety-conditions-or-its-unsound">Unsafe code must accurately document its safety conditions, or it's unsound</a></h3>
<p>The &quot;safety conditions&quot; for unsafe traits and functions are just the conditions
under which it does not trigger undefined behavior. These conditions aren't
checked by the compiler, they're checked by the people who write the code
itself. Therefore, unsafe blocks must be manually checked to verify that the
code written upholds all of the conditions required to avoid undefined behavior.
Any unsafe code that can trigger undefined behavior <em>even when its safety
conditions are upheld</em> is unsound.</p>
<h2 id="common-misconceptions"><a class="header" href="#common-misconceptions">Common misconceptions</a></h2>
<p>There are a couple misconceptions about UB that often muddy the water when talking about it.</p>
<h3 id="if-it-works-its-sound"><a class="header" href="#if-it-works-its-sound">&quot;If it works, it's sound&quot;</a></h3>
<p>Undefined Behavior may be present even if the compiler does end up compiling the
code according to the programmer's intent. A future version of the compiler may
behave differently, or future changes to an innocuous portion of the code may
cause it to fall to the other side of an invisible threshold. Technically it
may even compile differently but only on Tuesdays, though that type of
nondeterminism is generally rare.</p>
<h3 id="ub-is-about-what-the-optimizer-is-allowed-to-do"><a class="header" href="#ub-is-about-what-the-optimizer-is-allowed-to-do">&quot;UB is about what the optimizer is allowed to do&quot;</a></h3>
<p>This is to <em>some extent</em> true but the actual situation is far more nuanced.</p>
<p>It's common for people to think about UB in terms of what an optimizer &quot;is and
isn't allowed to do&quot;, and in terms of optimizations they know can occur. For
example, it's pretty straightforward to see that sneakily writing to memory
that you're not supposed to can cause undefined behavior when the optimizer
decides to elide a memory read that occurs after your illicit write.</p>
<p>Firstly, some forms of UB just have to do with rules the underlying processor
enforces.</p>
<p>But more than that, there are plenty of miscompiles that are hard to explain by
simply thinking in terms of why the optimizer would do such a thing.</p>
<p>This is because it's less about what the optimizer is allowed to <em>do</em> and more
about what it is allowed to <em>assume</em>. When a program has UB, the optimizer may
make an incorrect assumption that snowballs into bigger and bigger incorrect
assumptions that cause very unexpected behavior.</p>
<p>It's often very <em>useful</em> to think of potential optimizations the optimizer may
do around your code, but that is not sufficient for evaluating whether your
code has UB.</p>
<p>Throughout this book there will be examples of how various optimizations may
break code exhibiting undefined behavior, however it is crucial to learn the
rule behind the breakage rather than just the nature of the optimization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-unsafety"><a class="header" href="#core-unsafety">Core unsafety</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dangling-and-unaligned-pointers"><a class="header" href="#dangling-and-unaligned-pointers">Dangling and unaligned pointers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invalid-values"><a class="header" href="#invalid-values">Invalid values</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-races"><a class="header" href="#data-races">Data races</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intrinsics"><a class="header" href="#intrinsics">Intrinsics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abi-and-ffi"><a class="header" href="#abi-and-ffi">ABI and FFI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-features"><a class="header" href="#platform-features">Platform features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-unsafety"><a class="header" href="#advanced-unsafety">Advanced unsafety</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uninitialized-memory"><a class="header" href="#uninitialized-memory">Uninitialized memory</a></h1>
<blockquote>
<p><em>&quot;I'm Nobody! Who are you? Are you — Nobody — too?&quot;</em></p>
<p>— <em>Emily Dickinson</em></p>
</blockquote>
<p>While we have covered <a href="advanced_unsafety/../core_unsafety/invalid_values.html">invalid values</a>, there's another thing that is a kind of invalid value, but has nothing to do with actual bit patterns: Uninitialized memory.</p>
<h2 id="safely-working-with-uninitialized-memory"><a class="header" href="#safely-working-with-uninitialized-memory">Safely working with uninitialized memory</a></h2>
<p>The basic rule of thumb is: never refer to uninitialized memory with anything other than a raw pointer or something wrapped in <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a>. Having a stack value or temporary that is uninitialized and has a type that is not <code>MaybeUninit&lt;T&gt;</code>  (or an array of <code>MaybeUninit</code>s) is always undefined behavior.</p>
<p>A good model for uninitialized memory is that there's an additional value that does not map to any concrete bit pattern (think of it as &quot;byte value #257&quot;), but can be introduced in the abstract machine in various ways, and makes <em>most</em> values invalid.</p>
<p>Any attempt to read uninitialized bytes as a &quot;type that cares about initializedness&quot; will be UB, and the presence of this byte in non-padding locations is considered UB for most types. Most types care about initialized-ness; and the list of types that doesn't derives from treating initializedness as a property of the byte:</p>
<ul>
<li>Zero-sized types do not care about initializedness, since they do not have bytes</li>
<li>Unions do not care about initializedness if they have a variant that does not care about initialized-ness</li>
<li><a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a> does not care about initializedness since it is internally a union of <code>T</code> and a zero-sized type.</li>
<li><code>[MaybeUninit&lt;T&gt;; N]</code> <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#initializing-an-array-element-by-element">does not care about initializedness</a> since it doesn't have any bytes that care about initializedness</li>
</ul>
<p>Fundamentally, initializedness is a property of memory, but whether or not initializedness matters is a property of the access (in particular, of the <em>type</em> used by the access). For types that care about initializedness, typed operations working with uninitialized memory are typically UB, and having a value that contains uninitialized memory is immediately UB.</p>
<p><a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code>ptr::copy</code></a> is explicitly an <em>untyped</em> copy, and thus it will copy all bytes, including padding, and including initialized-ness, to the destination, regardless of the type <code>T</code>.</p>
<p>Most other operations copying a type (for example, <code>*ptr</code> and <code>mem::transmute_copy</code>) will be typed, and will thus ignore padding and be UB if ever fed uninitialized memory in non-padding positions (assuming the type involved cares about initializedness). This also applies to <code>let x = y</code> and <code>mem::transmute</code>, however in those cases if the source data were uninitialized that would already have been UB.</p>
<p>If you explicitly wish to work with uninitialized and partially-initialized types, <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a> is a useful abstraction since it can be constructed with no overhead and then written to in parts. It's also useful to e.g. refer to an uninitialized buffer with things like <code>&amp;mut [MaybeUninit&lt;u8&gt;]</code>.</p>
<p>Similarly with invalid values, there are open issues (<a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/77">UGC #77</a>, <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/346">UGC #346</a>) about whether it is UB to have <em>references</em> to uninitialized memory. When writing unsafe code we recommend you avoid creating such references, choosing to always use <code>MaybeUninit</code>. When auditing unsafe code, there may be cases where references to uninitialized values are actually safe as long as no uninitialized values are read out of it. In particular, <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/346">UGC #346</a> indicates that it is extremely unlikely that having <code>&amp;mut</code> references to uninitialized values will be immediately UB.</p>
<h2 id="sources-of-uninitialized-memory"><a class="header" href="#sources-of-uninitialized-memory">Sources of uninitialized memory</a></h2>
<h3 id="memuninitialized-and-maybeuninitassume_init"><a class="header" href="#memuninitialized-and-maybeuninitassume_init"><code>mem::uninitialized()</code> and <code>MaybeUninit::assume_init()</code></a></h3>
<p><a href="https://doc.rust-lang.org/stable/std/mem/fn.uninitialized.html"><code>mem::uninitialized()</code></a> is a deprecated API that has a very tempting shape: it lets you do things like <code>let x = mem::uninitialized()</code> when you want to construct an uninitialized value. It's <em>almost always</em> UB to use since it immediately sets <code>x</code> to uninitialized memory, which is UB because uninitialized memory is an invalid value for almost all types and it's unsound to produce invalid values.</p>
<p>Use <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a> instead.</p>
<p>It is still possible to create uninitialized values using <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.uninit"><code>MaybeUninit::uninit()</code></a> with <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init"><code>MaybeUninit::assume_init()</code></a> if you have not, in fact, assured that things are initialized.</p>
<p><code>mem::uninitialized()</code> is exactly equivalent to <code>MaybeUninit::uninit().assume_init()</code>, but it is deprecated since <code>MaybeUninit</code> actually provides the flexibility needed to deal with uninitialized memory safely.</p>
<h3 id="padding"><a class="header" href="#padding">Padding</a></h3>
<p>Padding bytes in structs and enums are <a href="https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/glossary.md#padding">usually but not always uninitialized</a>. This means that treating a struct as a bag of bytes (by, say, treating <code>&amp;Struct</code> as <code>&amp;[u8; size_of::&lt;Struct&gt;()]</code> and reading from there) is UB even if you don't write invalid values to those bytes, since you are accessing uninitialized <code>u8</code>s.</p>
<p>The &quot;usually but not always&quot; caveat can be usefully framed as &quot;padding bytes are uninitialized unless proven otherwise&quot;. Padding is a property of the <em>access</em> (i.e., the <em>type</em>), not memory, and these bytes are set to being uninitialized whenever a type is created or copied/moved around, but they can be written to by getting a reference to the memory behind the type<sup class="footnote-reference"><a href="#1">1</a></sup>, and will be preserved at that spot in memory as long as the type isn't overwritten as a whole.</p>
<p>For example, treating an initialized byte buffer as an <code>&amp;Struct</code> and then later reading the padding bytes will give initialized values. However, treating an initialized byte buffer as an <code>&amp;mut Struct</code> and then writing a new <code>Struct</code> to it will lead to those bytes becoming uninitialized since the <code>Struct</code> copy will &quot;copy&quot; the uninitialized padding bytes. Similarly, using <code>mem::transmute()</code> (or <code>mem::zeroed()</code>) to transmute a byte buffer to a <code>Struct</code> will uninitialize the padding because it performs a typed copy of the <code>Struct</code>.</p>
<p>Because <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code>ptr::copy</code></a> is an untyped copy, it can be used to copy over explicitly-initialized padding.</p>
<p>See the discussion in [UGC #395][ugc395] for more examples.</p>
<h3 id="unions"><a class="header" href="#unions">Unions</a></h3>
<p>Reading a union type as the wrong variant can lead to reading uninitialized memory, for example if the union was initialized to a smaller variant, or if the padding of the two variants don't overlap perfectly.</p>
<p>Rust does not have strict aliasing like C and C++: type punning with a union is safe as long as the corresponding transmute is safe.</p>
<p><a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html"><code>MaybeUninit&lt;T&gt;</code></a> is actually just a union between <code>T</code> and <code>()</code> under the hood: the rules for correct usage of <code>MaybeUninit</code> are the same as the rules for correct usage of a union.</p>
<h3 id="freshly-allocated-memory"><a class="header" href="#freshly-allocated-memory">Freshly allocated memory</a></h3>
<p>Freshly allocated memory (e.g. the yet-unused bytes in <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.with_capacity"><code>Vec::with_capacity()</code></a> or just the result of <a href="https://doc.rust-lang.org/stable/std/alloc/trait.Allocator.html#tymethod.allocate"><code>Allocator::allocate()</code></a>) is usually uninitialized. You can use APIs like <a href="https://doc.rust-lang.org/stable/std/alloc/trait.Allocator.html#method.allocate_zeroed"><code>Allocator::allocate_zeroed()</code></a> if you wish to avoid this, though you can still end up making <a href="advanced_unsafety/../core_unsafety/invalid_values.html">invalid values</a> the same way you can with <a href="https://doc.rust-lang.org/stable/std/mem/fn.zeroed.html"><code>mem::zeroed()</code></a>.</p>
<p>Generally after allocating memory one should make sure that the only part of that memory being read from is known to have been written to. This can be tricky in situations around complex data structures like probing hashtables where you have a buffer which only has some segments initialized, determined by complex conditions.</p>
<h3 id="not-exactly-uninitialized-moved-from-values"><a class="header" href="#not-exactly-uninitialized-moved-from-values">Not exactly uninitialized: Moved-from values</a></h3>
<p>The following code is UB:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ptr;
</span>let x = String::new(); // String is not Copy
let mut v = vec![];
let ptr = &amp;x as *const String;

v.push(x); // move x into the vector

unsafe {
    // dangling pointer reads from moved-from memory
    let ghost = ptr::read(ptr);
}
<span class="boring">}</span></code></pre></pre>
<p>Any type of move will do this, even when you &quot;move&quot; the value into a different variable with stuff like <code>let y = x;</code>.</p>
<p>This isn't <em>quite</em> uninitialized: it's just that using after a move is straight up UB in Rust, much like reading from freed memory. In particular, unlike most pointers to uninitialized values, this dangling pointer is unsound to <em>write</em> to as well.</p>
<p>Working with dangling pointers can often lead to similar problems as working with uninitialized values.</p>
<p>Note that Rust does let you &quot;partially move&quot; out of fields of a struct, in such a case the whole struct is now no longer a valid value for its type, but you are still allowed to &quot;use&quot; the struct to look at other fields, and the value as a whole is no longer usable. When doing such things, make sure there are no pointers that still think the struct is whole and valid.</p>
<h4 id="caveat-ptrdrop_in_place-manuallydropdrop-and-ptrread"><a class="header" href="#caveat-ptrdrop_in_place-manuallydropdrop-and-ptrread">Caveat: <code>ptr::drop_in_place()</code>, <code>ManuallyDrop::drop()</code>, and <code>ptr::read()</code></a></h4>
<p><a href="https://doc.rust-lang.org/stable/std/ptr/fn.drop_in_place.html"><code>ptr::drop_in_place()</code></a> and <a href="https://doc.rust-lang.org/stable/std/mem/struct.ManuallyDrop.html#method.drop"><code>ManuallyDrop::drop()</code></a> are interesting: they both call the destructor<sup class="footnote-reference"><a href="#2">2</a></sup> on a value (or a pointed-to value in the case of <code>drop_in_place</code>). From the perspective of safety they are identical; they are just different APIs for dealing with manually calling destructors.</p>
<p><a href="https://doc.rust-lang.org/stable/std/mem/struct.ManuallyDrop.html#method.drop"><code>ManuallyDrop::drop()</code></a> makes the following claim:</p>
<blockquote>
<p>Other than changes made by the destructor itself, the memory is left unchanged, and so as far as the compiler is concerned still holds a bit-pattern which is valid for the type T.</p>
</blockquote>
<p>In other words, Rust does <em>not</em> consider these operations to do the same invalidation as a regular &quot;move from&quot; operation, even though they may have a similar feel. They do not create dangling pointers, and they do not themselves overwrite the memory with an uninitialized value.</p>
<p>There is an <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/394">open issue</a> about whether <code>Drop::drop()</code> is itself allowed to produce uninitialized or invalid memory, so it may not be possible to rely on this in a generic context.</p>
<p><a href="https://doc.rust-lang.org/stable/std/ptr/fn.read.html"><code>ptr::read()</code></a> similarly claims that it leaves the source memory untouched, which means that it is still a valid value. Of course, <a href="https://doc.rust-lang.org/stable/std/ptr/fn.read.html"><code>ptr::read()</code></a> on a pointer pointing to uninitialized memory will still create an uninitialized value.</p>
<p>For all of these APIs, actually <em>using</em> the dropped or read-from memory may still be fraught depending on the invariants of the value; it's quite easy to cause a double-free by materializing an owned value from the original data after it has already been read-from or dropped.</p>
<p>However, they do not produce uninitialized memory.</p>
<p>Still, it is convenient when writing unsafe code to operate as if these functions produce uninitialized memory on the original source location.</p>
<h2 id="when-you-might-end-up-making-an-uninitialized-value"><a class="header" href="#when-you-might-end-up-making-an-uninitialized-value">When you might end up making an uninitialized value</a></h2>
<p>Some of the APIs and methods above create uninitialized memory in a pretty straightforward way — don't call <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init"><code>MaybeUninit::assume_init()</code></a> if things are not actually initialized!</p>
<p>When writing tricky data structures you may end up mistakenly assuming uninitialized memory is initialized. For example imagine building a probing hashmap, backed with allocated memory: only inhabited buckets will be initialized, and if your logic for determining which buckets are inhabited is broken, your code may risk producing uninitialized values.</p>
<p>A subtle case is when you <em>write</em> to uninitialized memory the wrong way. The following code uses a write to a <code>*mut String</code> that is pointing to uninitialized memory, and exhibits undefined behavior:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::mem::MaybeUninit;
</span>let mut val: MaybeUninit&lt;String&gt; = MaybeUninit::uninit();
let ptr: *mut String = val.as_mut_ptr();
unsafe {
    // UB!
    *ptr = String::from(&quot;hello world&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>This is UB because writing to raw pointers, under the hood, still calls destructors on the old value, the same way a write to an <code>&amp;mut T</code> does. This is usually quite convenient, but here the old value is uninitialized, and calling a destructor on it is undefined.</p>
<p>APIs like <a href="https://doc.rust-lang.org/stable/std/ptr/fn.write.html"><code>ptr::write()</code></a> and <a href="https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.write"><code>MaybeUninit::write()</code></a> exist to sidestep this problem. Logically, a write to a raw pointer is functionally the same as a <a href="https://doc.rust-lang.org/stable/std/ptr/fn.read.html"><code>ptr::read()</code></a> of the pointer (with the read-value being dropped) followed by a <a href="https://doc.rust-lang.org/stable/std/ptr/fn.write.html"><code>ptr::write()</code></a> with the new value.</p>
<h2 id="signs-an-uninitialized-value-was-involved"><a class="header" href="#signs-an-uninitialized-value-was-involved">Signs an uninitialized value was involved</a></h2>
<p>This is largely similar to the situation for <a href="advanced_unsafety/../core_unsafety/invalid_values.html">invalid values</a>: The compiler is allowed to assume memory is never uninitialized, and since uninitialized memory is a kind of invalid value, all of the failure modes of <a href="advanced_unsafety/../core_unsafety/invalid_values.html">invalid values</a> are possible.</p>
<p>Often when reading from uninitialized memory you'll see reads to the same, unchanged, memory producing different values.</p>
<p>This is not an exhaustive list: ultimately, having an uninitialized value is UB and it remains illegal even if there are no optimizations that will break.</p>
<p><sup class="footnote-reference"><a href="#1">1</a></sup>: Be sure to use <code>&amp;[MaybeUninit&lt;u8&gt;]</code> if treating a type with uninitialized padding as manipulatable memory!
<sup class="footnote-reference"><a href="#2">2</a></sup>: The &quot;destructor&quot; is different from the <code>Drop</code> trait. Calling the destructor is the process of calling a type's <code>Drop::drop</code> impl if it exists, and then calling the destructor for all of its fields (also known as &quot;drop glue&quot;). I.e. it's not <em>just</em> <code>Drop</code>, but rather the entire <em>destruction</em>, of which the destructor is one part. Types that do not implement <code>Drop</code> may still have contentful destructors if their transitive fields do.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointer-aliasing"><a class="header" href="#pointer-aliasing">Pointer aliasing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immutable-data"><a class="header" href="#immutable-data">Immutable data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-ordering"><a class="header" href="#atomic-ordering">Atomic ordering</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pinning"><a class="header" href="#pinning">Pinning</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variance"><a class="header" href="#variance">Variance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expert-unsafety"><a class="header" href="#expert-unsafety">Expert unsafety</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stacked-borrows"><a class="header" href="#stacked-borrows">Stacked borrows</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointer-provenance"><a class="header" href="#pointer-provenance">Pointer provenance</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
