<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Undefined behavior - Learn unsafe Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="undefined_behavior.html" class="active"><strong aria-hidden="true">2.</strong> Undefined behavior</a></li><li class="chapter-item expanded "><a href="core_unsafety.html"><strong aria-hidden="true">3.</strong> Core unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_unsafety/invalid_values.html"><strong aria-hidden="true">3.1.</strong> Invalid values</a></li><li class="chapter-item expanded "><a href="core_unsafety/dangling_and_unaligned_pointers.html"><strong aria-hidden="true">3.2.</strong> Dangling and unaligned pointers</a></li><li class="chapter-item expanded "><a href="core_unsafety/data_races.html"><strong aria-hidden="true">3.3.</strong> Data races</a></li><li class="chapter-item expanded "><a href="core_unsafety/intrinsics.html"><strong aria-hidden="true">3.4.</strong> Intrinsics</a></li><li class="chapter-item expanded "><a href="core_unsafety/abi_and_ffi.html"><strong aria-hidden="true">3.5.</strong> ABI and FFI</a></li><li class="chapter-item expanded "><a href="core_unsafety/platform_features.html"><strong aria-hidden="true">3.6.</strong> Platform features</a></li><li class="chapter-item expanded "><a href="core_unsafety/inline_assembly.html"><strong aria-hidden="true">3.7.</strong> Inline assembly</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_unsafety.html"><strong aria-hidden="true">4.</strong> Advanced unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_unsafety/pointer_aliasing.html"><strong aria-hidden="true">4.1.</strong> Pointer aliasing</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/immutable_data.html"><strong aria-hidden="true">4.2.</strong> Immutable data</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/atomic_ordering.html"><strong aria-hidden="true">4.3.</strong> Atomic ordering</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/undef_memory.html"><strong aria-hidden="true">4.4.</strong> Undef memory</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/pinning.html"><strong aria-hidden="true">4.5.</strong> Pinning</a></li><li class="chapter-item expanded "><a href="advanced_unsafety/variance.html"><strong aria-hidden="true">4.6.</strong> Variance</a></li></ol></li><li class="chapter-item expanded "><a href="expert_unsafety.html"><strong aria-hidden="true">5.</strong> Expert unsafety</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="expert_unsafety/stacked_borrows.html"><strong aria-hidden="true">5.1.</strong> Stacked borrows</a></li><li class="chapter-item expanded "><a href="expert_unsafety/pointer_provenance.html"><strong aria-hidden="true">5.2.</strong> Pointer provenance</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn unsafe Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="undefined-behavior"><a class="header" href="#undefined-behavior">Undefined behavior</a></h1>
<p>&quot;Undefined behavior&quot; is a bit of a strange notion. On one hand, the reference
<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">clearly defines</a> some (but not all) causes of undefined behavior.
This list includes some causes that are generally well-known: dereferencing a
null pointer, causing a data race, executing incorrect inline assembly. These
all have a direct translation for real, common machines and so it is common to
misunderstand &quot;undefined behavior&quot; to be &quot;platform-specific behavior&quot;. Maybe on
x86 it will continue on, perhaps on ARM it will cause a fault. While this can be
true, undefined behavior is usually more nuanced because of:</p>
<h2 id="abstract-machines"><a class="header" href="#abstract-machines">Abstract machines</a></h2>
<p>High-level programming languages allow programming for a wide variety of targets
by abstracting away the specific properties of each one, and targeting a single
&quot;abstract machine&quot;. C and C++ have their own &quot;abstract machines&quot;, and so does
Rust. This means that the semantics and rules of an abstract machine depend
heavily on the language that it's for.</p>
<p>When we write Rust code, we're writing code for this abstract machine. We're not
writing code that follows the rules for some set of targets; there is only one
set of rules for the abstract machine. It's just that the <em>consequences</em> for
breaking those rules depends on the target and the compiler itself. With this
perspective, it's easier to see that undefined behavior is platform-independent.</p>
<h2 id="rusts-abstract-machine"><a class="header" href="#rusts-abstract-machine">Rust's abstract machine</a></h2>
<p>Rust's abstract machine has not been rigorously defined, and it may never be.
Efforts to rigorously define Rust's abstract machine are usually colloquially
called &quot;standardizing Rust&quot;. You may even have heard of some of these efforts,
like the <a href="https://ferrous-systems.com/blog/the-ferrocene-language-specification-is-here/">Ferrocene Language Specification</a>. It's important to note
that these standards are for <em>some language arbitrarily close to Rust</em>; they're
not standards for the official Rust language.</p>
<p>Rather than describing the entirety of Rust's abstract machine, Rust's official
reference has defined just some of the rules of the abstract machine. Breaking
one of these rules definitely results in undefined behavior. These are the rules
that we'll cover in the <a href="./core_unsafety.html">Core unsafety</a> and
<a href="./advanced_unsafety.html">Advanced unsafety</a> volumes. There are also ideas about
undefined behavior that are being explored right now, but they haven't been
officially adopted as rules yet. Some of these are covered in the
<a href="./expert_unsafety.html">Expert unsafety</a> volume.</p>
<h2 id="triggering-undefined-behavior"><a class="header" href="#triggering-undefined-behavior">Triggering undefined behavior</a></h2>
<p>Undefined behavior in Rust is always triggered by some condition being met, and
usually this condition is just &quot;some code getting executed in a particular way&quot;
or &quot;some code violating an invariant upheld by the compiler&quot;. Because of this,
it's often tempting to think of undefined behavior as telling your program &quot;if
you get here, do whatever you want&quot;. However, undefined behavior is a purely
compile-time concept. It's not telling your program &quot;do whatever you want&quot;, it's
telling the compiler &quot;assume this can never happen&quot;. The compiler may not have a
better response than saying &quot;if you get here, panic&quot;. Or, it may be able to use
that promise to better optimize your code.</p>
<p>As an example, consider this Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hint::unreachable_unchecked;

unsafe fn char_to_int(c: char) -&gt; u8 {
    match c {
        '0' =&gt; 0,
        '1' =&gt; 1,
        '2' =&gt; 2,
        '3' =&gt; 3,
        '4' =&gt; 4,
        '5' =&gt; 5,
        '6' =&gt; 6,
        '7' =&gt; 7,
        '8' =&gt; 8,
        '9' =&gt; 9,
        _ =&gt; unsafe { unreachable_unchecked() },
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This converts a char <code>'0'..'9'</code> to its corresponding integer value. In the last
arm of the match, we call <code>unreachable_unchecked()</code>, which is a compiler hint
that says &quot;it would be undefined behavior to reach here&quot;. Because we promised
the compiler that <code>c</code> won't be any value other than <code>0..9</code>, it could optimize
this function into something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn char_to_int(c: char) -&gt; u8 {
    c as u8 - b'0'
}
<span class="boring">}</span></code></pre></pre>
<p>Consider what would happen if we called <code>char_to_int('A')</code>. <code>'A'</code> has a value of
<code>65</code> as a <code>u8</code>, and <code>'0'</code> has a value of <code>48</code> as a <code>u8</code>. So the optimized
version of our function would return <code>17</code>. But what if the compiler chose to
optimize our function a different way instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn char_to_int(c: char) -&gt; u8 {
    c as u8 &amp; 0b1111
}
<span class="boring">}</span></code></pre></pre>
<p>This does the same thing as our original version for all characters <code>'0'..'9'</code>.
Now consider what <em>this version</em> of our function would do if we called
<code>char_to_int('A')</code>. <code>'A'</code> has a value of <code>65</code> (<code>0b0010_0001</code> in binary
notation), so this version would return <code>0010_0111 &amp; 0000_1111 = 0111 = 15</code>.
This is a different result than we would have gotten with the previous
optimization!</p>
<p>Finally, consider this version:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn char_to_int(c: char) -&gt; u8 {
    let c = c as u8;
    if c &lt; b'0' || c &gt; b'9' {
        panic!()
    } else {
        c - b'0'
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This version doesn't return anything, it panics! In fact, the compiler would be
allowed to put <em>anything</em> in where the <code>panic!()</code> is located; the resulting
function would be just as correct and optimal as this one.</p>
<p>This strikes at the core of what &quot;undefined behavior&quot; is. The Rust compiler
transforms code based on a set of assumptions that always hold. If you break one
of these assumptions, then the behavior of your program is undefined because
it's impossible to know what transforms the compiler is doing based on them.</p>
<h2 id="unsoundness"><a class="header" href="#unsoundness">Unsoundness</a></h2>
<p>Now that we know exactly what undefined behavior is, we can understand what it
means for some Rust code to be <em>unsound</em>. Unsound code refers to either:</p>
<ul>
<li>An abstraction (e.g. a function or a trait) that can trigger undefined
behavior even when used as prescribed.</li>
<li>A particular invocation of unsafe code that causes undefined behavior under
allowed circumstances.</li>
</ul>
<p>This leads to two broad rules:</p>
<h3 id="if-you-can-trigger-undefined-behavior-with-purely-safe-code-its-unsound"><a class="header" href="#if-you-can-trigger-undefined-behavior-with-purely-safe-code-its-unsound">If you can trigger undefined behavior with purely safe code, it's unsound</a></h3>
<p>In purely safe code (that is, code that contains no <code>unsafe</code> blocks), the
compiler is in charge of enforcing all of the rules to avoid undefined behavior.
If we somehow manage to cause undefined behavior, then there must be some API
that we use which is unsound.</p>
<p>This is also why it can be difficult to build safe abstractions around unsafe
code. It's your job as the abstraction designer to make sure that no possible
arrangement of safe code can cause undefined behavior. That's a lot to consider!</p>
<h3 id="unsafe-code-must-accurately-document-its-safety-conditions-or-its-unsound"><a class="header" href="#unsafe-code-must-accurately-document-its-safety-conditions-or-its-unsound">Unsafe code must accurately document its safety conditions, or it's unsound</a></h3>
<p>The &quot;safey conditions&quot; for unsafe traits and functions are just the conditions
under which it does not trigger undefined behavior. These conditions aren't
checked by the compiler, they're checked by the people who write the code
itself. Therefore, unsafe blocks must be manually checked to verify that the
code written upholds all of the conditions required to avoid undefined behavior.
Any unsafe code that can trigger undefined behavior <em>even when its safey
conditions are upheld</em> is unsound.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="core_unsafety.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="core_unsafety.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
